/* simulator.c
   Copyright (C) 2017 Ferdinand Blomqvist

   This program is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License version 2 as published by
   the Free Software Foundation. 

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program. If not, see <http://www.gnu.org/licenses/>.  
   
   Written by Ferdinand Blomqvist. */

#include "dbg.h"
#include "simulator.h"
#include "channel.h"
#include "rng.h"
#include <time.h>
#include <stdio.h>
#include <math.h>
#include <gsl/gsl_permutation.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_blas.h>

#define EPSILON 10E-10

#define HASHLINE "########################################"
#define EXPORT_PREAMBLE HASHLINE "\n"\
        "# Generated by %s\n"\
        "# at %s\n"\
        "# with the following options:\n"

#define TABLE_VLINE "+----------+--------------+------------+"\
                    "------------+------------------+----------------+"

typedef struct s_decoder_workspace
{
    double* decoded;
    double* transmitted;
    double* received;
    gsl_vector_view v_d;
    gsl_vector_view v_r;
} SIM_WS;

typedef struct s_simulation_status
{
    size_t frames;
    size_t frame_errs;
    size_t bit_errs;
    double sigma;
    double vnr_rms;
} SIM_STATUS;

struct s_simulator
{
    gsl_matrix* basis;
    void* alg_ws;
    FILE* outfile;
    CHANNEL* channel;
    void (*get_received)(CHANNEL*);
    SOLVE_func decode;
    size_t (*is_decoding_error)(SIM_WS*, size_t len, size_t*);
    double vnr;
    size_t total;
    size_t dt_size;
    size_t n;
    size_t m;
    double rate;
    double vol;
    Algorithm alg;
    int cutoff_reached;
};

static void init_function_pointers(SIMULATOR* sim, SIM_OPTIONS* opt);

static size_t is_not_zero_codeword(SIM_WS* ws, size_t len, size_t* bit_errs);
static size_t is_frame_error(SIM_WS* ws, size_t len, size_t* bit_errs);

static void process_cword(SIMULATOR* sim, SIM_OPTIONS* opt, 
                        SIM_WS* ws, SIM_STATUS* status);

static int read_cword_binary(void* cword, size_t cword_len, size_t dt_size);

static void simulation_status_init(SIM_STATUS* status, SIMULATOR* sim);

static int simulation_zero_cword_run_vnr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws);
static int simulation_read_cword_run_vnr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws);

static SIM_WS* SIM_WS_alloc(size_t n, size_t size, int zero_cwords);
static void SIM_WS_free(SIM_WS* ws);

static int sim_print_configuration(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix);

static int sim_print_information(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix);

static int sim_print_table_headers(FILE* file);
static int sim_print_table_footer(FILE* file);

static int sim_print_vnr_result(FILE* file, double vnr, size_t frame_errs, 
                        size_t bit_errs, size_t frames, size_t bits);

static int sim_print_time_and_speed(FILE* file, size_t frames, 
                                    size_t bits, double time_elapsed);

static int compute_volume(double* vol, const gsl_matrix* B);

int SIMULATOR_from_basis(SIMULATOR** sim_ptr, gsl_matrix* basis, Algorithm alg)
{
    int lt_errno = LT_SUCCESS;
    SIMULATOR* sim = malloc(sizeof(SIMULATOR));
    libcheck_se_mem(sim, lt_errno, LT_ESYSTEM);

    lt_errno = algorithm_get_fp_init_ws(&sim->decode, &sim->alg_ws, alg, basis);
    lt_llibcheck(lt_errno, error_a, "algorithm_get_fp_init_ws failed");

    sim->basis = basis;
    sim->alg = alg;
    sim->n = basis->size1;
    sim->m = basis->size2;
    sim->cutoff_reached = 0;
    sim->rate = (double) sim->m / sim->n;
    
    lt_errno = compute_volume(&sim->vol, basis);
    lt_llibcheck(lt_errno, error_b, "compute_volume failed");

    debug("rate: %f", sim->rate);
    debug("volume: %f", sim->vol);

    // Temporary
    sim->dt_size = sizeof(double);
    *sim_ptr = sim;
    return lt_errno;

error_b:
    algorithm_free_ws(sim->alg_ws, sim->alg);
error_a:
    free(sim);
error:
    *sim_ptr = NULL;
    return lt_errno;
}

void SIMULATOR_free(SIMULATOR* sim)
{
    if(sim)
    {
        algorithm_free_ws(sim->alg_ws, sim->alg);
        gsl_matrix_free(sim->basis);
        free(sim);
    }
}

int SIMULATOR_run(SIMULATOR* sim, SIM_OPTIONS* opt)
{
    int ret = LT_FAILURE;
    SIM_WS* ws = SIM_WS_alloc(sim->n, sim->dt_size, opt->zero_cwords);
    check_mem(ws);

    opt->seed = opt->seed ? opt->seed : (unsigned long) time(NULL) + clock();
    gsl_rng* rng = rng_alloc_and_seed(opt->rng_type, opt->seed);
    lcheck_mem(rng, error_a);

    sim->channel = CHANNEL_alloc(ws->received, ws->transmitted, sim->n, 0, rng);
    lcheck_mem(sim->channel, error_b);

    sim->outfile = fopen(opt->outfile, "w");
    lcheck(sim->outfile, error_c, "could not open '%s' for writing", opt->outfile);

    sim_print_configuration(sim->outfile, opt, sim->n, sim->m, sim->rate, "# ");
    sim_print_information(stdout, opt, sim->n, sim->m, sim->rate, "");
    sim_print_table_headers(stdout);

    init_function_pointers(sim, opt);

    int (*simulation_run_vnr)(SIMULATOR*, SIM_OPTIONS*, SIM_WS*) 
        = opt->zero_cwords 
        ? simulation_zero_cword_run_vnr : simulation_read_cword_run_vnr;

    sim->vnr = opt->vnr_begin;
    sim->total = 0;

    time_t start = time(NULL);
    while(sim->vnr < (opt->vnr_end + 0.001) && !sim->cutoff_reached)
    {
        int rc = simulation_run_vnr(sim, opt, ws);
        llibcheck(rc == 0, error_d, "simulation_run_vnr failed");
        sim->vnr += opt->vnr_step;
    }

    sim_print_table_footer(stdout);

    double time_elapsed = difftime(time(NULL), start);
    sim_print_time_and_speed(stdout, sim->total, sim->total * sim->n, time_elapsed);

    ret = LT_SUCCESS;
    
error_d:
    fclose(sim->outfile);
error_c:
    CHANNEL_free(sim->channel);
error_b:
    gsl_rng_free(rng);
error_a:
    SIM_WS_free(ws);
error:
    return ret;
}

static void init_function_pointers(SIMULATOR* sim, SIM_OPTIONS* opt)
{
    sim->get_received = opt->zero_cwords ? 
        channel_get_zero_cword_AWGN : channel_get_cword_AWGN;
    sim->is_decoding_error = opt->zero_cwords ? 
            is_not_zero_codeword : is_frame_error;
}


static size_t is_not_zero_codeword(SIM_WS* ws, size_t len, size_t* bit_errs)
{
    double* cword = ws->decoded;
    size_t errors = 0; 
    for(size_t i = 0; i < len; i++)
        if(fabs(cword[i]) > EPSILON) 
            errors++;

    *bit_errs += errors;
    return (errors ? 1 : 0);
}

static size_t is_frame_error(SIM_WS* ws, size_t len, size_t* bit_errs)
{
    double* cword = ws->decoded;
    double* transmitted = ws->transmitted;
    size_t errors = 0;
    for(size_t i = 0; i < len; i++)
        if(fabs(cword[i] - transmitted[i]) > EPSILON)
            errors++;

    *bit_errs += errors;
    return (errors ? 1 : 0);
}

static void process_cword(SIMULATOR* sim, SIM_OPTIONS* opt, 
                        SIM_WS* ws, SIM_STATUS* status)
{
    sim->get_received(sim->channel);
    sim->decode(&ws->v_d.vector, &ws->v_r.vector, sim->basis, sim->alg_ws);
    status->frame_errs += sim->is_decoding_error(ws, sim->n, &status->bit_errs);
    status->frames++;
}

static int read_cword_binary(void* cword, size_t cword_len, size_t dt_size)
{
    size_t rc = fread(cword, dt_size, cword_len, stdin);
    check(rc == cword_len, "fread failed");
    return 0;

error:
    if(feof(stdin))
    {
        log_err_ne("Could not read the next codeword; end of file reached");
        clearerr(stdin);
    }
    return -1;
}

static void simulation_status_init(SIM_STATUS* status, SIMULATOR* sim)
{
    status->frames = 0;
    status->frame_errs = 0;
    status->bit_errs = 0;
    double sigma = sqrt(sim->vol / (sim->rate * pow(10.0, sim->vnr / 10.0)));
    CHANNEL_set_sigma(sim->channel, sigma);
    debug("sigma: %f", sigma);
}

static int simulation_cutoff_reached(SIMULATOR* sim, SIM_STATUS* status, SIM_OPTIONS* opt)
{
    const size_t bits = status->frames * sim->n;
    const double fer = (double) status->frame_errs / status->frames;
    const double ber = (double) status->bit_errs / bits;
    return fer <= opt->frame_err_cutoff || ber <= opt->bit_err_cutoff;
}

static int simulation_zero_cword_run_vnr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws)
{
        SIM_STATUS status;
        simulation_status_init(&status, sim);

        while(status.frame_errs < opt->min_err)
            process_cword(sim, opt, ws, &status);

        sim->total += status.frames;
        sim_print_vnr_result(sim->outfile, sim->vnr, status.frame_errs,
                            status.bit_errs, status.frames, status.frames * sim->n);
        sim->cutoff_reached = simulation_cutoff_reached(sim, &status, opt);
        return 0;
}

static int simulation_read_cword_run_vnr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws)
{
        SIM_STATUS status;
        simulation_status_init(&status, sim);

        while(status.frame_errs < opt->min_err)
        {
            int rc = read_cword_binary(ws->transmitted, sim->n, sim->dt_size);
            libcheck(rc == 0, "read_cword_binary failed");

            process_cword(sim, opt, ws, &status);
        }

        sim->total += status.frames;
        sim_print_vnr_result(sim->outfile, sim->vnr, status.frame_errs,
                            status.bit_errs, status.frames, status.frames * sim->n);
        sim->cutoff_reached = simulation_cutoff_reached(sim, &status, opt);
        return 0;

error:
    return -1;
}

static SIM_WS* SIM_WS_alloc(size_t n, size_t size, int zero_cwords)
{
    SIM_WS* ws = malloc(sizeof(SIM_WS));
    libcheck_mem(ws);

    ws->decoded = malloc(n * size);
    llibcheck_mem(ws->decoded, error_a);

    if(zero_cwords)
        ws->transmitted = NULL;
    else
    {
        ws->transmitted = malloc(n * size);
        llibcheck_mem(ws->transmitted, error_b);
    }

    ws->received = malloc(n * sizeof(double));
    llibcheck_mem(ws->received, error_c);
    ws->v_d = gsl_vector_view_array(ws->decoded, n);
    ws->v_r = gsl_vector_view_array(ws->received, n);
    return ws;

error_c:
    free(ws->transmitted);
error_b:
    free(ws->decoded);
error_a:
    free(ws);
error:
    return NULL;
}

static void SIM_WS_free(SIM_WS* ws)
{
    free(ws->decoded);
    free(ws->transmitted);
    free(ws->received);
    free(ws);
}

static int sim_print_configuration(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix)
{
    char timestr[32];
    time_t timer = time(NULL);
    struct tm* tm_info = localtime(&timer);
    strftime(timestr, 32, "%Y-%m-%d %H:%M:%S", tm_info);

    int rc = fprintf(file, EXPORT_PREAMBLE, PROGRAM_NAME, timestr);
    check(rc >= 0, "printing error");

    rc = fprintf(file, "%s\n%sMaximum number of iterations: %zu\n"
                        "%sFrame errors awaited per VNR: %zu\n"
                        "%sVNR begin: %.2f\n"
                        "%sVNR end: %.2f\n"
                        "%sVNR step: %.2f\n"
                        "%sCode read from: %s\n"
                        "%sOutput file: %s\n"
                        "%sSeed: %lu\n"
                        "%sRNG: %s\n"
                        "%sUsing Log-Likelihood ratios: %s\n"
                        "%sTo-max-iter: %s\n"
                        "%sArray base: %zu\n"
                        "%sInput format: %s\n"
                        "%s\n%sCode parameters: n = %zu, k = %zu, rate = %.2f\n"
                        "%s\n",
                        prefix, prefix, (size_t)0, 
                        prefix, opt->min_err, 
                        prefix, opt->vnr_begin,
                        prefix, opt->vnr_end,
                        prefix, opt->vnr_step,
                        prefix, opt->infile, 
                        prefix, opt->outfile,
                        prefix, opt->seed,
                        prefix, opt->rng_type->name,
                        prefix, 0 ? "YES" : "NO",
                        prefix, 0 ? "YES" : "NO",
                        prefix, 0,
                        prefix, "TODO",
                        prefix, prefix, n, k, rate,
                        HASHLINE);
    check(rc >= 0, "printing error");
    return 0;

error:
    return -1;
}

static int sim_print_information(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix)
{
    //fprintf(file, "%sNumber of Iterations = %zu\n", prefix, opt->max_iter);
    fprintf(file, "%sVNR from %f to %f in increments of %f\n", prefix, 
            opt->vnr_begin, opt->vnr_end, opt->vnr_step);
    fprintf(file, "%s%zu frame errors awaited per VNR\n", prefix, opt->min_err);
    fprintf(file, "%s\n%sCode parameters: n=%zu, k=%zu (hence rate = %f)\n\n", 
            prefix, prefix, n, k, rate);
    int rc = fprintf(file, "%sRNG: %s\n", prefix, opt->rng_type->name);
    check(rc >= 0, "printing error");

    rc = fprintf(file, "%sSeed: %ld\n", prefix, opt->seed);
    check(rc >= 0, "printing error");
    return 0;

error:
    return -1;
}

static int sim_print_table_headers(FILE* file)
{
    return fprintf(file, TABLE_VLINE "\n| %-9s| %-13s| %-11s| %-11s| %-17s| %-15s|\n" 
            TABLE_VLINE "\n", "VNR (dB)", "Frame-errors", "Bit-errors", "Frames", 
            "Frame-error rate", "Bit-error rate"); 
}

static int sim_print_table_footer(FILE* file)
{ return fprintf(file, TABLE_VLINE "\n\n"); }

static int sim_print_vnr_result(FILE* file, double vnr, size_t frame_errs, 
                        size_t bit_errs, size_t frames, size_t bits)
{
    double fer = (double) frame_errs / frames;
    double ber = (double) bit_errs / bits;
    int rc =  fprintf(stdout, "|%9.4f |%13zu |%11zu |%11zu |%17.8e |%15.8e |\n", 
                    vnr, frame_errs, bit_errs, frames, fer, ber); 
    libcheck(rc >= 0, "printing error");

    rc =  fprintf(file, "%f\t%zu\t%zu\t%zu\t%.8e\t%.8e\n", 
                    vnr, frame_errs, bit_errs, frames, fer, ber);
    libcheck(rc >= 0, "printing error");
    libcheck(fflush(file) == 0, "fflush failed");
    return 0;

error:
    return -1;
}

static int sim_print_time_and_speed(FILE* file, size_t frames, 
                                    size_t bits, double time_elapsed)
{
    return fprintf(file,"Program has processed %zu frames in %f Seconds\n"
            "Resulting throughput is %f Mb/sec\n", frames, time_elapsed,
            bits / (time_elapsed * 1024 *1024)) > 0 ? 0 : -1;
}

static int compute_volume(double* vol, const gsl_matrix* B)
{
    int lt_errno = LT_SUCCESS;
    const size_t m = B->size2;

    gsl_matrix* G = gsl_matrix_alloc(m, m);
    libcheck_se_mem(G, lt_errno, GSL_ENOMEM);

    gsl_permutation* perm = gsl_permutation_alloc(m);
    llibcheck_se_mem(perm, error_a, lt_errno, GSL_ENOMEM);

    lt_errno = gsl_blas_dgemm(CblasTrans, CblasNoTrans, 1.0, B, B, 0.0, G);
    lt_llibcheck(lt_errno, error_b, "gsl_blas_dgemm failed");

    int signum;
    lt_errno = gsl_linalg_LU_decomp(G, perm, &signum);
    lt_llibcheck(lt_errno, error_b, "gsl_linalg_LU_decomp failed");

    *vol = pow(gsl_linalg_LU_det(G, signum), 2.0 / m);

error_b:
    gsl_permutation_free(perm);
error_a:
    gsl_matrix_free(G);
error:
    return lt_errno;
}
