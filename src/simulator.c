/* simulator.c
   Copyright (C) 2017 Ferdinand Blomqvist

   This program is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License version 2 as published by
   the Free Software Foundation. 

   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
   more details.

   You should have received a copy of the GNU General Public License along with
   this program. If not, see <http://www.gnu.org/licenses/>.  
   
   Written by Ferdinand Blomqvist. */

#include "dbg.h"
#include "simulator.h"
#include "channel.h"
#include "rng.h"
#include <time.h>
#include <stdio.h>
#include <math.h>

#define EPSILON 10E-10

#define HASHLINE "########################################"
#define EXPORT_PREAMBLE HASHLINE "\n"\
        "# Generated by %s\n"\
        "# at %s\n"\
        "# with the following options:\n"

#define TABLE_VLINE "+----------+--------------+------------+"\
                    "-----------+------------------+----------------+"

typedef struct s_decoder_workspace
{
    double* decoded;
    double* transmitted;
    double* received;
    gsl_vector_view v_d;
    gsl_vector_view v_r;
} SIM_WS;

typedef struct s_simulation_status
{
    size_t frames;
    size_t frame_errs;
    size_t bit_errs;
    double sigma;
    double snr_rms;
} SIM_STATUS;

struct s_simulator
{
    gsl_matrix* basis;
    void* alg_ws;
    FILE* outfile;
    CHANNEL* channel;
    void (*get_received)(CHANNEL*);
    SOLVE_func decode;
    size_t (*is_decoding_error)(SIM_WS*, size_t len, size_t*);
    double snr;
    size_t total;
    size_t dt_size;
    size_t n;
    size_t m;
    double rate;
    Algorithm alg;
};

static void init_function_pointers(SIMULATOR* sim, SIM_OPTIONS* opt);

static size_t is_not_zero_codeword(SIM_WS* ws, size_t len, size_t* bit_errs);
static size_t is_frame_error(SIM_WS* ws, size_t len, size_t* bit_errs);

static void process_cword(SIMULATOR* sim, SIM_OPTIONS* opt, 
                        SIM_WS* ws, SIM_STATUS* status);

static int read_cword_binary(void* cword, size_t cword_len, size_t dt_size);

static void simulation_status_init(SIM_STATUS* status, SIMULATOR* sim);

static int simulation_zero_cword_run_snr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws);
static int simulation_read_cword_run_snr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws);

static SIM_WS* SIM_WS_alloc(size_t n, size_t size, int zero_cwords);
static void SIM_WS_free(SIM_WS* ws);

static int sim_print_configuration(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix);

static int sim_print_information(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix);

static int sim_print_table_headers(FILE* file);
static int sim_print_table_footer(FILE* file);

static int sim_print_snr_result(FILE* file, double snr, size_t frame_errs, 
                        size_t bit_errs, size_t frames, size_t bits);

static int sim_print_time_and_speed(FILE* file, size_t frames, 
                                    size_t bits, double time_elapsed);

SIMULATOR* SIMULATOR_from_basis(gsl_matrix* basis, Algorithm alg)
{
    SIMULATOR* sim = malloc(sizeof(SIMULATOR));
    libcheck_mem(sim);

    int rc = algorithm_get_fp_init_ws(&sim->decode, &sim->alg_ws, alg, basis);
    llibcheck(rc == 0, error_a, "algorithm_get_fp_init_ws failed");

    sim->basis = basis;
    sim->alg = alg;
    sim->n = basis->size1;
    sim->m = basis->size2;
    sim->rate = (double) sim->m / sim->n;

    // Temporary
    sim->dt_size = sizeof(double);
    return sim;

error_a:
    free(sim);
error:
    return NULL;
}

void SIMULATOR_free(SIMULATOR* sim)
{
    if(sim)
    {
        algorithm_free_ws(sim->alg_ws, sim->alg);
        gsl_matrix_free(sim->basis);
        free(sim);
    }
}

int SIMULATOR_run(SIMULATOR* sim, SIM_OPTIONS* opt)
{
    int ret = EXIT_FAILURE;
    SIM_WS* ws = SIM_WS_alloc(sim->n, sim->dt_size, opt->zero_cwords);
    check_mem(ws);

    opt->seed = opt->seed ? opt->seed : (unsigned long) time(NULL) + clock();
    gsl_rng* rng = rng_alloc_and_seed(opt->rng_type, opt->seed);
    lcheck_mem(rng, error_a);

    sim->channel = CHANNEL_alloc(ws->received, ws->transmitted, sim->n, 0, rng);
    lcheck_mem(sim->channel, error_b);

    sim->outfile = fopen(opt->outfile, "w");
    lcheck(sim->outfile, error_c, "could not open '%s' for writing", opt->outfile);

    sim_print_configuration(sim->outfile, opt, sim->n, sim->m, sim->rate, "# ");
    sim_print_information(stdout, opt, sim->n, sim->m, sim->rate, "");
    sim_print_table_headers(stdout);

    init_function_pointers(sim, opt);

    int (*simulation_run_snr)(SIMULATOR*, SIM_OPTIONS*, SIM_WS*) 
        = opt->zero_cwords 
        ? simulation_zero_cword_run_snr : simulation_read_cword_run_snr;

    sim->snr = opt->snr_begin;
    sim->total = 0;

    time_t start = time(NULL);
    while(sim->snr < (opt->snr_end + 0.001))
    {
        int rc = simulation_run_snr(sim, opt, ws);
        llibcheck(rc == 0, error_d, "simulation_run_snr failed");
        sim->snr += opt->snr_step;
    }

    sim_print_table_footer(stdout);

    double time_elapsed = difftime(time(NULL), start);
    sim_print_time_and_speed(stdout, sim->total, sim->total * sim->n, time_elapsed);

    ret = EXIT_SUCCESS;
    
error_d:
    fclose(sim->outfile);
error_c:
    CHANNEL_free(sim->channel);
error_b:
    gsl_rng_free(rng);
error_a:
    SIM_WS_free(ws);
error:
    return ret;
}

static void init_function_pointers(SIMULATOR* sim, SIM_OPTIONS* opt)
{
    sim->get_received = opt->zero_cwords ? 
        channel_get_zero_cword_AWGN : channel_get_cword_AWGN;
    sim->is_decoding_error = opt->zero_cwords ? 
            is_not_zero_codeword : is_frame_error;
}


static size_t is_not_zero_codeword(SIM_WS* ws, size_t len, size_t* bit_errs)
{
    double* cword = ws->decoded;
    size_t errors = 0; 
    for(size_t i = 0; i < len; i++)
        if(fabs(cword[i]) > EPSILON) 
            errors++;

    *bit_errs += errors;
    return (errors ? 1 : 0);
}

static size_t is_frame_error(SIM_WS* ws, size_t len, size_t* bit_errs)
{
    double* cword = ws->decoded;
    double* transmitted = ws->transmitted;
    size_t errors = 0;
    for(size_t i = 0; i < len; i++)
        if(fabs(cword[i] - transmitted[i]) > EPSILON)
            errors++;

    *bit_errs += errors;
    return (errors ? 1 : 0);
}

static void process_cword(SIMULATOR* sim, SIM_OPTIONS* opt, 
                        SIM_WS* ws, SIM_STATUS* status)
{
    sim->get_received(sim->channel);
    //sim->init_costs(sim->tg, ws->received, status->snr_rms);
    sim->decode(&ws->v_d.vector, &ws->v_r.vector, sim->basis, sim->alg_ws);
    status->frame_errs += sim->is_decoding_error(ws, sim->n, &status->bit_errs);
    status->frames++;
}

static int read_cword_binary(void* cword, size_t cword_len, size_t dt_size)
{
    size_t rc = fread(cword, dt_size, cword_len, stdin);
    check(rc == cword_len, "fread failed");
    return 0;

error:
    if(feof(stdin))
    {
        log_err_ne("Could not read the next codeword; end of file reached");
        clearerr(stdin);
    }
    return -1;
}

static void simulation_status_init(SIM_STATUS* status, SIMULATOR* sim)
{
    status->frames = 0;
    status->frame_errs = 0;
    status->bit_errs = 0;
    double sigma_sqr_inv = 2.0 * sim->rate * pow(10.0, (sim->snr / 10.0));
    status->snr_rms = 2.0 * sigma_sqr_inv;     // 2/sigma^2
    CHANNEL_set_sigma(sim->channel, 1.0 / sqrt(sigma_sqr_inv));
    //printf("Sigma: %f\n", 1.0 / sqrt(sigma_sqr_inv));
}

static int simulation_zero_cword_run_snr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws)
{
        SIM_STATUS status;
        simulation_status_init(&status, sim);

        while(status.frame_errs < opt->min_err)
            process_cword(sim, opt, ws, &status);

        sim->total += status.frames;
        sim_print_snr_result(sim->outfile, sim->snr, status.frame_errs,
                            status.bit_errs, status.frames, status.frames * sim->n);
        return 0;
}

static int simulation_read_cword_run_snr(SIMULATOR* sim, SIM_OPTIONS* opt, SIM_WS* ws)
{
        SIM_STATUS status;
        simulation_status_init(&status, sim);

        while(status.frame_errs < opt->min_err)
        {
            int rc = read_cword_binary(ws->transmitted, sim->n, sim->dt_size);
            libcheck(rc == 0, "read_cword_binary failed");

            process_cword(sim, opt, ws, &status);
        }

        sim->total += status.frames;
        sim_print_snr_result(sim->outfile, sim->snr, status.frame_errs,
                            status.bit_errs, status.frames, status.frames * sim->n);
        return 0;

error:
    return -1;
}

static SIM_WS* SIM_WS_alloc(size_t n, size_t size, int zero_cwords)
{
    SIM_WS* ws = malloc(sizeof(SIM_WS));
    libcheck_mem(ws);

    ws->decoded = malloc(n * size);
    llibcheck_mem(ws->decoded, error_a);

    if(zero_cwords)
        ws->transmitted = NULL;
    else
    {
        ws->transmitted = malloc(n * size);
        llibcheck_mem(ws->transmitted, error_b);
    }

    ws->received = malloc(n * sizeof(double));
    llibcheck_mem(ws->received, error_c);
    ws->v_d = gsl_vector_view_array(ws->decoded, n);
    ws->v_r = gsl_vector_view_array(ws->received, n);
    return ws;

error_c:
    free(ws->transmitted);
error_b:
    free(ws->decoded);
error_a:
    free(ws);
error:
    return NULL;
}

static void SIM_WS_free(SIM_WS* ws)
{
    free(ws->decoded);
    free(ws->transmitted);
    free(ws->received);
    free(ws);
}

static int sim_print_configuration(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix)
{
    char timestr[32];
    time_t timer = time(NULL);
    struct tm* tm_info = localtime(&timer);
    strftime(timestr, 32, "%Y-%m-%d %H:%M:%S", tm_info);

    int rc = fprintf(file, EXPORT_PREAMBLE, PROGRAM_NAME, timestr);
    check(rc >= 0, "printing error");

    rc = fprintf(file, "%s\n%sMaximum number of iterations: %zu\n"
                        "%sFrame errors awaited per SNR: %zu\n"
                        "%sSNR begin: %.2f\n"
                        "%sSNR end: %.2f\n"
                        "%sSNR step: %.2f\n"
                        "%sCode read from: %s\n"
                        "%sOutput file: %s\n"
                        "%sSeed: %lu\n"
                        "%sRNG: %s\n"
                        "%sUsing Log-Likelihood ratios: %s\n"
                        "%sTo-max-iter: %s\n"
                        "%sArray base: %zu\n"
                        "%sInput format: %s\n"
                        "%s\n%sCode parameters: n = %zu, k = %zu, rate = %.2f\n"
                        "%s\n",
                        prefix, prefix, (size_t)0, 
                        prefix, opt->min_err, 
                        prefix, opt->snr_begin,
                        prefix, opt->snr_end,
                        prefix, opt->snr_step,
                        prefix, opt->infile, 
                        prefix, opt->outfile,
                        prefix, opt->seed,
                        prefix, opt->rng_type->name,
                        prefix, 0 ? "YES" : "NO",
                        prefix, 0 ? "YES" : "NO",
                        prefix, 0,
                        prefix, "TODO",
                        prefix, prefix, n, k, rate,
                        HASHLINE);
    check(rc >= 0, "printing error");
    return 0;

error:
    return -1;
}

static int sim_print_information(FILE* file, SIM_OPTIONS* opt, size_t n, 
                                size_t k, double rate, const char* prefix)
{
    fprintf(file, "%sLog-Likelihood Decoding of LDPC Codes\n", prefix);
    //fprintf(file, "%sNumber of Iterations = %zu\n", prefix, opt->max_iter);
    fprintf(file, "%sSNR from %f to %f in increments of %f\n", prefix, 
            opt->snr_begin, opt->snr_end, opt->snr_step);
    fprintf(file, "%s%zu frame errors awaited per SNR\n", prefix, opt->min_err);
    fprintf(file, "%s\n%sCode parameters: n=%zu, k=%zu (hence rate = %f)\n\n", 
            prefix, prefix, n, k, rate);
    int rc = fprintf(file, "%sRNG: %s\n", prefix, opt->rng_type->name);
    check(rc >= 0, "printing error");

    rc = fprintf(file, "%sSeed: %ld\n", prefix, opt->seed);
    check(rc >= 0, "printing error");
    return 0;

error:
    return -1;
}

static int sim_print_table_headers(FILE* file)
{
    return fprintf(file, TABLE_VLINE "\n| %-9s| %-13s| %-11s| %-10s| %-17s| %-15s|\n" 
            TABLE_VLINE "\n", "SNR", "Frame-errors", "Bit-errors", "Frames", 
            "Frame-error rate", "Bit-error rate"); 
}

static int sim_print_table_footer(FILE* file)
{ return fprintf(file, TABLE_VLINE "\n\n"); }

static int sim_print_snr_result(FILE* file, double snr, size_t frame_errs, 
                        size_t bit_errs, size_t frames, size_t bits)
{
    double fer = (double) frame_errs / frames;
    double ber = (double) bit_errs / bits;
    int rc =  fprintf(stdout, "|%9f |%13zu |%11zu |%10zu |%17.8e |%15.8e |\n", 
                    snr, frame_errs, bit_errs, frames, fer, ber); 
    libcheck(rc >= 0, "printing error");

    rc =  fprintf(file, "%f\t%zu\t%zu\t%zu\t%.8e\t%.8e\n", 
                    snr, frame_errs, bit_errs, frames, fer, ber);
    libcheck(rc >= 0, "printing error");
    libcheck(fflush(file) == 0, "fflush failed");
    return 0;

error:
    return -1;
}

static int sim_print_time_and_speed(FILE* file, size_t frames, 
                                    size_t bits, double time_elapsed)
{
    return fprintf(file,"Program has processed %zu frames in %f Seconds\n"
            "Resulting throughput is %f Mb/sec\n", frames, time_elapsed,
            bits / (time_elapsed * 1024 *1024)) > 0 ? 0 : -1;
}
